#!/usr/bin/env python
# -*- coding: utf-8 -*-

#импорт из модуля datetime класса datetime
from datetime import datetime
#импорт модуля для работы с файлами в кодировке utf-8
import codecs
#импорт модуля, который умеет парсить json строки в питоновские объекты (dict/list)
import json
#импорт модуля, который умеет работать с HTTP запросами
import requests
#ну тут понятно
import random

class MyEncoder(json.JSONEncoder):
	'''
	класс, используемый нами как сериализатор объектов, которые мы хочешь преобразовать в json строку
	он наследуется от json.JSONEncoder, чтобы модуль json принимать его, как класс-сериализатор
	'''
	def default(self, o):
		'''
		метод, который как раз таки вызывается где-то внутри модуля 
		json у переданного в функцию сериализации класса сериализатора
		'''
		#возвращаем для объекта o его внутреннее свойство __dict___
		#нужно это для того, чтобы json смог сериализовать классы, как dict
		#	пример
		#	у класса A есть переменная color, которая имеет значение 'red'
		#	__dict__ вернет дикшинари вида { 'color':'red' }
		return o.__dict__

def log(*tuple): 
	'''
	метод для удобного вывода логов в консоль, подцепляя в начало строки текущую дату и время,
	а также, отлавливает exception'ы, которые может выкинуть print(),
	так как нам эти экзепшены не должны крашить бота
	'''
	try:
		#выводим те аргументы, которые нам передали как tuple
		print(datetime.now(), ":", *tuple, "\n")
	except Exception:
		#ловим экзепшены всех видов, так как они все унаследованы от класса Exception
		#если наш задуманный print() не удался, то выводим следующую строчку вместо него
		print(datetime.now(), ":", "a very strange log")

def try_parse_int(s, val=None):
	'''
	метод принимает строку s, возвращает число, если она его содержала
	если не смогли мы вытащить из этой строки число, что равно вывалился exception класса ValueError,
	то возвращает None или другое значение, передаваемое опционально вторым аргументом
	'''
	try:
		return int(s, 10)
	except ValueError:
		return val

def save_to_json(obj, file):
	'''
	метод для сохранения объектов в json формате в файл с кодировкой utf-8
	'''
	#перед именем файла подставляем имя папки data, в которой и будут наши
	#файлы с данными храниться, а не в папке с исходными файлами
	file = 'data/'+file
	#сериализуем наш объект obj в строку json формата, 
	#indent=4 -	отформатированную четыремя пробелами для отступов
	#sort_keys=True - 	с отсортированными в алфавитном порядке ключами, если это dict
	data = json.dumps(obj, cls=MyEncoder, indent=4, sort_keys=True, ensure_ascii=False)
	#октрываем файлик для записи
	f = codecs.open(file, encoding='utf-8', mode='w')
	#пишем туда нашу строку
	f.write(data)
	#закрываем файлик
	f.close()
	#пишем лог, что успешно сохранили такой-то файл
	log('saved json file',file)

def load_from_json(file, val = None):
	'''
	аналогично save_to_json(), только в обратную сторону

	возвращает объект, соответствующий json строке в файле
	если Exception, возвращает значение val
	'''
	file = 'data/'+file
	try:
		f = codecs.open(file, encoding='utf-8', mode='r')
		#десериализуем строку, которую прочитаем из файла в объект obj
		obj = json.loads(f.read())
		f.close()
		#возвращаем этот объект
		return obj
	except Exception as ex:
		#логаем, что не смогли прочитать json из такого-то файла, и описание экзепшена
		log("Can't load obj from file",file,"\nException: ",ex)
		#если что-то пошло не так, например файла file нет или не получилось десериализовать json строку в объект,
		#возвращаем значение, переданное вторым аргументом (или None)
		return val